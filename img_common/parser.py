""" Class that parses the output of run_model.py """


from pathlib import Path
import glob
import tensorflow as tf
import numpy as np
import bitstring
import gzip
import json
import pandas as pd
import shutil
import os
import subprocess
import re
from PIL import Image
import matplotlib.pyplot as plt
from itertools import repeat, product
from img_common.enums import Folders


class Parser:
    """ Class with functions to parse the output of run_model.py """
    def __init__(self, folder):
        self.run_folder = Path(folder)
        self.raw_folder = self.run_folder / str(Folders.RAW_DATA)
        self.parsed_folder = self.run_folder / str(Folders.PARSED_DATA)

        json_path = glob.glob(folder + '/*.json')[0]
        with open(str(json_path), 'r') as config:
            json_c = json.load(config)

        self.db_rec_glob = json_c['run']['data_loader']['recursive_glob']
        self.recursive = json_c['model']['configs']['recursive']
        self.num_imgs = json_c['run']['data_loader']['num_data']
        self.quantized_latent = json_c['model']['configs']['quantized_latent']

    def _save_jpeg_analysis(self):
        """
        Method that makes jpeg analysis in the current database. In the
        case of jpeg it's useful because the codec works with nominal
        quality, not one directly converted into psnr / bpp. This method saves
        all jpeg calculated metrics for each quality in a csv file.
        """
        img_array = sorted(glob.glob(self.db_rec_glob, recursive=True))
        img_array = img_array[:self.num_imgs]
        img_array = np.array(list(map(lambda p: Path(p), img_array)))
        csv_array = np.array(list(map(
            lambda p: p.parent / 'jpeg' / p.with_suffix('.jpeg.csv').name,
            img_array)))

        print('Making jpeg analysis on the database folder!', end='\n')
        for img_path, csv_path in zip(img_array, csv_array):
            if not csv_path.parent.exists():
                csv_path.parent.mkdir(parents=True, exist_ok=True)
            if csv_path.exists():
                continue

            print(img_path)
            img = tf.image.decode_image(tf.io.read_file(str(img_path)))
            tf_range = tf.range(0, 101)
            jpeg_enc = Parser.my_map(lambda q:
                                     tf.image.encode_jpeg(img, quality=q),
                                     tf_range, dtype=tf.string,
                                     parallel_iterations=10)
            pixel_num = int(np.prod(img.shape[:-1]))
            bpp = np.array(list(map(lambda e: bitstring.Bits(e.numpy()).length /
                                    pixel_num, jpeg_enc)))

            jpeg_img = Parser.my_map(tf.image.decode_jpeg, jpeg_enc,
                                     dtype=tf.uint8, parallel_iterations=10)
            del jpeg_enc
            psnr, ssim, msssim = self._calc_metrics(img, jpeg_img)
            del jpeg_img

            data = np.stack((tf_range, psnr, ssim, msssim, bpp), axis=1)
            df = pd.DataFrame(data, columns=['quality', 'psnr', 'ssim',
                                             'msssim', 'bpp'])
            df.set_index('quality', inplace=True)
            df.to_csv(csv_path)

    def _load_net_output_data(self, orig_path):
        """
        Function that reads the latents and images generated by the model.

        @type orig_path: PosixPath
        @param orig_path: Path containing the data generated by the model
        (images and latents).

        @rtype: tf.Tensor
        @return: Returns three tf.Tensors, respectively:
                 1. Tensor representing the original img (tf.uint8 dtype).

                 2. Tensor representing the reconstructed img (tf.uint8 dtype).

                 3. Tensor representing the latents (tf.int8 if quantized_latent
                    is True).
        """
        data_stem = str(self.raw_folder / orig_path.stem)

        latent_list = tf.constant(sorted(glob.glob(data_stem + '*_latent*')))
        img_list = tf.constant(sorted(glob.glob(data_stem + '*.png')))

        orig_img = self.read_img_fn(str(orig_path))
        raw_img = Parser.my_map(self.read_img_fn, img_list, dtype=tf.uint8,
                                parallel_iterations=10)
        raw_latent = Parser.my_map(self.read_tensor, latent_list,
                                   dtype=tf.float32, parallel_iterations=10)
        if self.quantized_latent:
            raw_latent = Parser.my_map(self.cast_to_int8,
                                       raw_latent, dtype=tf.int8,
                                       parallel_iterations=10)

        return orig_img, raw_img, raw_latent

    def _process_raw_data(self, imgs, latents):
        """ Function that sums and concatenates the imgs / latents """

        # TF can't clip uint8 directly
        aux_imgs = list(map(lambda i: tf.image.convert_image_dtype(
            i, dtype=tf.float32), imgs))
        aux_imgs = list(map(lambda i: tf.clip_by_value(i, 0., 1.), aux_imgs))

        if not self.recursive:
            new_imgs = [tf.reduce_sum(aux_imgs[:i], axis=0)
                        for i in np.arange(1, len(aux_imgs) + 1)]
            new_imgs = list(map(lambda i: tf.clip_by_value(i, 0., 1.),
                                new_imgs))
        else:
            new_imgs = aux_imgs

        new_imgs = list(map(lambda i: tf.image.convert_image_dtype(
            i, dtype=tf.uint8), new_imgs))

        aux_latents = list(map(lambda i: tf.reshape(i, [-1]), latents))
        new_latents = [tf.concat(aux_latents[:i], axis=0)
                       for i in np.arange(1, len(aux_latents) + 1)]

        return new_imgs, new_latents

    @staticmethod
    def _calc_bpp(latent, pixels_num):
        """
        Function that calculates the bpp considering the gzip.
        WARNING: it always supposes that the latent is integer.

        @type latent: tf.Tensor
        @param latent: The binarized latents generated by the network.
        @type pixels_num: integer
        @param pixels_num: Number of pixels of original image.

        @rtype: float
        @return: bpp after compressing by gzip
        """
        latent = list(map(lambda x: x != -1, latent))
        compressed = gzip.compress(bitstring.Bits(latent).bytes)
        bpp = bitstring.Bits(compressed).length / pixels_num
        return bpp

    @staticmethod
    def _calc_metrics(orig_img, img_array):
        """
        Function that calculates the three image metrics: PSNR, SSIM, MS-SSIM.
        This function is called by L{_calc_net_metrics}, L{_save_jpeg_analysis}
        and L{_calc_jpeg2k_metrics}.

        @type orig_img: tf.Tensor
        @param orig_img: Tensor representing the original img.
        @type img_array: tf.Tensor
        @param img_array: Tensor representing the img compressed by the codec.

        @rtype: float
        @return: the three visual metrics.
        """
        orig_img = tf.cast(orig_img, tf.dtypes.uint8)
        img_array = tf.cast(img_array, tf.dtypes.uint8)
        psnr = Parser.my_map(lambda i: tf.image.psnr(orig_img, i, 255),
                             img_array, dtype=tf.float32,
                             parallel_iterations=10)
        ssim = Parser.my_map(lambda i: tf.image.ssim(orig_img, i, 255),
                             img_array, dtype=tf.float32,
                             parallel_iterations=10)
        msssim = Parser.my_map(
            lambda i: tf.image.ssim_multiscale(
                orig_img, i, 255,
                filter_size=min(
                    min(i.shape[0]//16, 11), min(i.shape[1]//16, 11))),
            img_array, dtype=tf.float32, parallel_iterations=10)

        return psnr, ssim, msssim

    def _calc_net_metrics(self, orig_path):
        """
        Function that calculates all metrics required for the network.

        @type orig_path: PosixPath
        @param orig_path: Path representing the image.

        @rtype: float
        @return: float numbers for the visual metrics psnr, ssim and ms-ssim and
        the rate bits per pixel (bpp).
        """
        def save_png(img, name):
            tf.io.write_file(name, tf.image.encode_png(img, compression=0))

        bpp_fn = lambda l, p: tf.numpy_function(self._calc_bpp, [l, p],
                                                np.float32)

        orig_img, net_imgs, net_latents = self._load_net_output_data(orig_path)
        imgs, latents = self._process_raw_data(net_imgs, net_latents)

        pixels = tf.reduce_prod(orig_img.shape[:-1])
        bpp = []
        for l in latents:
            bpp.append(bpp_fn(l, pixels))
        bpp = list(map(lambda b: b.numpy(), bpp))

        curr_stem = orig_path.stem
        curr_suffix = orig_path.suffix
        values = np.arange(len(imgs)).astype(str)

        new_name = self.parsed_folder / orig_path.name
        names = list(map(lambda v: str(new_name.with_name(
            curr_stem + '_' + v + curr_suffix)), values))

        list(map(save_png, imgs, names))

        psnr, ssim, msssim = self._calc_metrics(orig_img, imgs)
        psnr, ssim, msssim = psnr.numpy(), ssim.numpy(), msssim.numpy()

        return psnr, ssim, msssim, bpp

    @staticmethod
    def _match_jpeg_quality(csv_path, bpp_ref):
        """
        Auxiliary function of L{_calc_jpeg_metrics}. Get the jpeg
        corresponding quality considering the bpp passed as parameter.

        @type csv_path: PosixPath
        @param csv_path: csv path.
        @type bpp_ref: float
        @param bpp_ref: bpp to be considered.

        @rtype: Pandas Dataframe Series
        @return: Pandas row that best approximates the bpp_ref value.
        """
        df = pd.read_csv(csv_path)
        bpp = df.loc[:, 'bpp'].values
        items = df.loc[np.argmin(np.abs(bpp - bpp_ref))]
        return items

    @staticmethod
    def read_img_fn(p):
        return tf.image.decode_image(tf.io.read_file(p))

    @staticmethod
    def read_tensor(p):
        return tf.io.parse_tensor(tf.io.read_file(p), out_type=tf.float32)

    @staticmethod
    def cast_to_int8(t):
        return tf.cast(t, dtype=tf.int8)

    def _calc_jpeg_metrics(self, orig_path, bpp_ref):
        """
        Function that matches the jpeg metrics and save the corresponding
        images. It uses the csv generated by L{_save_jpeg_analysis} function
        to match the correct quality.

        @type orig_path: PosixPath
        @param orig_path: Original path of the image.
        @type bpp_ref: float
        @param bpp_ref: bpp of the image reconstructed by the network.

        @rtype: float
        @return: numbers representing psnr, ssim, ms-ssim and bpp of the image
                 compressed by jpeg2k.
        """
        def save_jpeg(img, name, quality):
            tf.io.write_file(name,
                             tf.image.encode_jpeg(img, quality=int(quality)))
        csv_path = ((orig_path.parent / 'jpeg') /
                    orig_path.with_suffix('.jpeg.csv').name)

        items = list(map(lambda bpp: self._match_jpeg_quality(csv_path, bpp),
                         bpp_ref))
        qualities, psnr, ssim, msssim, bpp = list(zip(*np.array(items)))

        orig_img = tf.image.decode_png(tf.io.read_file(str(orig_path)))

        jpeg_folder = self.parsed_folder / orig_path.with_suffix('.jpeg').name
        if not jpeg_folder.exists():
            jpeg_folder.mkdir()

        levels = np.arange(len(bpp))
        names_fmt = str(jpeg_folder / (orig_path.stem + '_{}.jpeg'))
        names = list(map(lambda n: names_fmt.format(n), levels))
        qualities = np.array(qualities).astype(np.int64)

        list(map(lambda n, q: save_jpeg(orig_img, n, q), names, qualities))

        return psnr, ssim, msssim, bpp

    @tf.function
    def my_map(*args, **kwargs):
        return tf.map_fn(*args, **kwargs)

    def _calc_jpeg2k_metrics(self, orig_path, bpp_ref):
        """
        Function that matches the jpeg2k metrics and save the corresponding
        images -> MUST INSTALL imagemagick: sudo apt install imagemagick. It
        takes the original image and generates a compressed version using jpeg2k
        in order to compare them.

        @type orig_path: PosixPath
        @param orig_path: Original path of the image.
        @type bpp_ref: float
        @param bpp_ref: bpp of the image reconstructed by the network.

        @rtype: float
        @return: numbers representing psnr, ssim, ms-ssim and bpp of the image
                 compressed by jpeg2k.
        """
        folder = self.parsed_folder
        jpeg2k_folder = folder / orig_path.with_suffix('.j2c').name
        if not jpeg2k_folder.exists():
            jpeg2k_folder.mkdir()

        levels = np.arange(len(bpp_ref))
        names_fmt = str(jpeg2k_folder / (orig_path.stem + '_{}.jp2'))
        names = list(map(lambda n: names_fmt.format(n), levels))

        # Convert to bmp (kakadu does not accept .png)
        bmp_path = str(jpeg2k_folder / orig_path.with_suffix('.bmp').name)
        to_bmp = 'convert \'' + str(orig_path) + '\' -alpha off ' + bmp_path
        if os.system(to_bmp):
            raise RuntimeError('Error on generating aux bmp file!')

        cmd_fmt = 'kdu_compress -i \'' + bmp_path + '\' -o \'{}\' -rate {}'
        cmd = list(map(lambda o, b: cmd_fmt.format(o, b), names, bpp_ref))
        ret = list(map(lambda c: subprocess.check_output(c, shell=True), cmd))
        ret = list(map(lambda r: r.decode('utf-8').replace('\n', ''), ret))
        pattern = re.compile(r'bit-rates.*(\d+\.\d+)')
        bpp = list(map(lambda r: pattern.search(r).group(1), ret))
        if None in bpp:
            raise RuntimeError('Error on generating jp2 files!')
        bpp = list(map(float, bpp))
        os.system('rm -f ' + bmp_path)

        img_ref = list(map(lambda p: Image.open(p), names))
        img_data = list(map(lambda p: np.array(p), img_ref))
        with Image.open(orig_path) as orig_ref:
            orig_data = np.array(orig_ref)
        psnr, ssim, msssim = self._calc_metrics(orig_data, img_data)
        psnr, ssim, msssim = psnr.numpy(), ssim.numpy(), msssim.numpy()
        return psnr, ssim, msssim, bpp

    def _save_metric_plot(self, orig_path, psnr_l, ssim_l, msssim_l, bpp_l):
        """
        Method that saves a scatter plot related to an image.

        @type orig_path: str
        @param orig_path: path of the image
        @type psnr_l: float
        @param psnr_l: psnr of the image
        @type ssim_l: float
        @param ssim_l: ssim of the image
        @type msssim_l: float
        @param msssim_l: msssim of the image
        @type bpp_l: float
        @param bpp_l: bpp of the image
        """

        metrics_names = ['psnr', 'ssim', 'msssim']
        legend = ['network', 'jpeg', 'jpeg2k']
        all_metrics = [psnr_l, ssim_l, msssim_l]
        title = str(orig_path.name) + ', {} x {}'
        markers = {0: 'o', 1: 's', 2: '>'}

        with Image.open(orig_path) as img:
            title = title.format(*img.size)

        for cont, metric in enumerate(all_metrics):
            plt.xlabel('bpp')
            plt.ylabel(metrics_names[cont])
            plt.grid(True)
            plt.title(title)
            plt.xticks(rotation=90)
            plt.tight_layout()
            for c_bpp, c_metric, cnt in zip(bpp_l, metric, range(len(legend))):
                plt.plot(c_bpp, c_metric, marker=markers[cnt], markersize=6,
                         linewidth=2)
            plt.legend(legend, loc='center right')
            plot_name = self.parsed_folder / (
                orig_path.stem + '_plot_' + str(metrics_names[cont]) +
                Path(orig_path.name).suffix)
            plt.savefig(str(plot_name), dpi=360)
            plt.close()

    def _save_out_analysis(self, paths, bpps, metrics, codec_name):
        """
        This method saves a csv containing the analysis for all images wrt all
        metrics for each codec.

        @type paths: list
        @param paths: contains the path of each image.
        @type bpps: list
        @param bpps: contains the bpp of each image.
        @type metrics: list
        @param metrics: contains the visual metrics (psnr, ssim and ms-ssim)
                        of each image.
        @type codec_name: string
        @param codec_name: string representing the codec.
        """
        csv_path = self.parsed_folder / ('_analysis_' + codec_name + '.csv')
        data = np.concatenate((bpps, *metrics), axis=1)
        names = ['bpp', 'psnr', 'ssim', 'msssim']
        levels = len(bpps[0])
        cols = [x[0] + str(x[1]) for x in product(names, range(levels))]
        df = pd.DataFrame(data, index=pd.Index(paths, name='img'),
                          columns=pd.Index(cols))
        df = df.sort_index()
        mean_df = pd.DataFrame(df.mean(axis=0).values.reshape(1, -1),
                               columns=df.columns, index=pd.Index(['mean']))
        full_df = pd.concat((df, mean_df))
        full_df.to_csv(str(csv_path), float_format='%.5f')

    def parse(self):
        """
        Main method to parse the output. It calculates the metrics for each
        codec and saves the analysis to a csv file by calling
        L{_save_out_analysis}.
        """
        self._save_jpeg_analysis()

        all_txt = tf.constant(glob.glob(str(self.raw_folder / '*.txt')))
        orig_paths = Parser.my_map(tf.io.read_file, all_txt, dtype=tf.string,
                                   parallel_iterations=10)
        orig_paths = list(map(Path, np.array(orig_paths).astype(str)))

        if self.parsed_folder.exists():
            shutil.rmtree(self.parsed_folder, ignore_errors=True)
        self.parsed_folder.mkdir()

        net_psnr, j_psnr, j2_psnr = [], [], []
        net_ssim, j_ssim, j2_ssim = [], [], []
        net_msssim, j_msssim, j2_msssim = [], [], []
        net_bpp, j_bpp, j2_bpp = [], [], []
        for orig_path in orig_paths:
            print('Processing', orig_path)

            psnr, ssim, msssim, bpp = self._calc_net_metrics(orig_path)
            net_psnr.append(psnr), net_ssim.append(ssim)
            net_msssim.append(msssim), net_bpp.append(bpp)

            psnr, ssim, msssim, bpp = self._calc_jpeg_metrics(
                orig_path, net_bpp[-1])
            j_psnr.append(psnr), j_ssim.append(ssim)
            j_msssim.append(msssim), j_bpp.append(bpp)

            psnr, ssim, msssim, bpp = self._calc_jpeg2k_metrics(
                orig_path, net_bpp[-1])
            j2_psnr.append(psnr), j2_ssim.append(ssim)
            j2_msssim.append(msssim), j2_bpp.append(bpp)

            self._save_metric_plot(
                orig_path, [net_psnr[-1], j_psnr[-1], j2_psnr[-1]],
                [net_ssim[-1], j_ssim[-1], j2_ssim[-1]],
                [net_msssim[-1], j_msssim[-1], j2_msssim[-1]],
                [net_bpp[-1], j_bpp[-1], j2_bpp[-1]])

        all_bpps = [net_bpp, j_bpp, j2_bpp]
        all_metrics = [[net_psnr, net_ssim, net_msssim],
                       [j_psnr, j_ssim, j_msssim],
                       [j2_psnr, j2_ssim, j2_msssim]]
        codecs = ['network', 'jpeg', 'jpeg2k']
        list(map(self._save_out_analysis, repeat(orig_paths), all_bpps,
                 all_metrics, codecs))
